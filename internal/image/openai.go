package image

import (
	"context"
	"crypto/md5"
	"encoding/hex"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
	
	"github.com/sashabaranov/go-openai"
)

// OpenAIClient implements ImageSearcher for OpenAI DALL-E image generation
type OpenAIClient struct {
	client      *openai.Client
	apiKey      string
	model       string // dall-e-2 or dall-e-3
	size        string // 256x256, 512x512, 1024x1024
	quality     string // standard or hd (dall-e-3 only)
	style       string // natural or vivid (dall-e-3 only)
	cacheDir    string
	enableCache bool
	lastPrompt  string // Store the last used prompt for attribution
}

// OpenAIConfig holds configuration for the OpenAI image provider
type OpenAIConfig struct {
	APIKey      string
	Model       string
	Size        string
	Quality     string
	Style       string
	CacheDir    string
	EnableCache bool
}

// NewOpenAIClient creates a new OpenAI DALL-E client
func NewOpenAIClient(config *OpenAIConfig) *OpenAIClient {
	if config.APIKey == "" {
		// Return nil client that will fail on operations
		return &OpenAIClient{}
	}
	
	client := openai.NewClient(config.APIKey)
	
	// Set defaults
	if config.Model == "" {
		config.Model = "dall-e-3"
	}
	if config.Size == "" {
		config.Size = "1024x1024"
	}
	if config.Quality == "" {
		config.Quality = "standard"
	}
	if config.Style == "" {
		config.Style = "natural"
	}
	if config.CacheDir == "" {
		config.CacheDir = "./.image_cache"
	}
	
	oc := &OpenAIClient{
		client:      client,
		apiKey:      config.APIKey,
		model:       config.Model,
		size:        config.Size,
		quality:     config.Quality,
		style:       config.Style,
		cacheDir:    config.CacheDir,
		enableCache: config.EnableCache,
	}
	
	// Create cache directory if caching is enabled
	if oc.enableCache && oc.cacheDir != "" {
		os.MkdirAll(oc.cacheDir, 0755)
	}
	
	return oc
}

// Search generates an image for the Bulgarian word using DALL-E
func (c *OpenAIClient) Search(ctx context.Context, opts *SearchOptions) ([]SearchResult, error) {
	if c.client == nil {
		return nil, &SearchError{
			Provider: "openai",
			Code:     "NO_API_KEY",
			Message:  "OpenAI API key not configured",
		}
	}
	
	// Check cache first
	if c.enableCache {
		cacheFile := c.getCacheFilePath(opts.Query)
		if info, err := os.Stat(cacheFile); err == nil && info.Size() > 0 {
			// Return cached result
			fmt.Printf("Using cached image for '%s'\n", opts.Query)
			result := SearchResult{
				ID:           c.generateImageID(opts.Query),
				URL:          cacheFile,
				ThumbnailURL: cacheFile,
				Width:        c.getSizeWidth(),
				Height:       c.getSizeHeight(),
				Description:  fmt.Sprintf("Generated image for %s", opts.Query),
				Attribution:  "Generated by OpenAI DALL-E",
				Source:       "openai",
			}
			return []SearchResult{result}, nil
		}
	}
	
	// Translate Bulgarian word to English for better results
	translatedWord, err := c.translateBulgarianToEnglish(ctx, opts.Query)
	if err != nil {
		// If translation fails, fall back to using the original word
		fmt.Printf("Translation failed: %v, using original word\n", err)
		translatedWord = opts.Query
	}
	
	// Create prompt - use custom if provided, otherwise generate educational prompt
	var prompt string
	if opts.CustomPrompt != "" {
		prompt = opts.CustomPrompt
		fmt.Printf("Using custom prompt: %s\n", prompt)
	} else {
		prompt = c.createEducationalPrompt(opts.Query, translatedWord)
	}
	
	// Store the prompt for attribution
	c.lastPrompt = prompt
	
	// Log the prompt to stdout for debugging
	fmt.Printf("OpenAI Image Generation Prompt: %s\n", prompt)
	fmt.Printf("OpenAI Image Generation: Using model '%s' with size '%s'\n", c.model, c.size)
	
	// Create the image generation request
	req := openai.ImageRequest{
		Prompt:         prompt,
		Model:          c.model,
		Size:           c.size,
		ResponseFormat: openai.CreateImageResponseFormatURL,
		N:              1,
	}
	
	// Add model-specific parameters
	if c.model == "dall-e-3" {
		req.Quality = c.quality
		req.Style = c.style
	}
	
	// Generate the image
	resp, err := c.client.CreateImage(ctx, req)
	if err != nil {
		return nil, &SearchError{
			Provider: "openai",
			Code:     "API_ERROR",
			Message:  fmt.Sprintf("Failed to generate image: %v", err),
		}
	}
	
	if len(resp.Data) == 0 {
		return nil, &SearchError{
			Provider: "openai",
			Code:     "NO_RESULTS",
			Message:  "No image generated",
		}
	}
	
	// Get the generated image URL
	imageURL := resp.Data[0].URL
	
	// Download and cache the image if caching is enabled
	if c.enableCache {
		cacheFile := c.getCacheFilePath(opts.Query)
		if err := c.downloadAndCache(ctx, imageURL, cacheFile); err == nil {
			// Update URL to point to cached file
			imageURL = cacheFile
		}
		// Continue even if caching fails
	}
	
	// Create result
	result := SearchResult{
		ID:           c.generateImageID(opts.Query),
		URL:          imageURL,
		ThumbnailURL: imageURL,
		Width:        c.getSizeWidth(),
		Height:       c.getSizeHeight(),
		Description:  fmt.Sprintf("Generated educational image for %s (%s)", opts.Query, translatedWord),
		Attribution:  "Generated by OpenAI DALL-E",
		Source:       "openai",
	}
	
	return []SearchResult{result}, nil
}

// Download downloads an image from the given URL
func (c *OpenAIClient) Download(ctx context.Context, url string) (io.ReadCloser, error) {
	// If it's a local cached file (not an HTTP/HTTPS URL), open it directly
	if !strings.HasPrefix(url, "http://") && !strings.HasPrefix(url, "https://") {
		file, err := os.Open(url)
		if err != nil {
			return nil, fmt.Errorf("failed to open cached file: %w", err)
		}
		return file, nil
	}
	
	// Otherwise download from URL
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, err
	}
	
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	
	if resp.StatusCode != http.StatusOK {
		resp.Body.Close()
		return nil, fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
	}
	
	return resp.Body, nil
}

// GetAttribution returns the required attribution text
func (c *OpenAIClient) GetAttribution(result *SearchResult) string {
	attribution := fmt.Sprintf("Image generated by OpenAI DALL-E\n\n")
	attribution += fmt.Sprintf("Model: %s\n", c.model)
	attribution += fmt.Sprintf("Size: %s\n", c.size)
	if c.model == "dall-e-3" {
		attribution += fmt.Sprintf("Quality: %s\n", c.quality)
		attribution += fmt.Sprintf("Style: %s\n", c.style)
	}
	attribution += fmt.Sprintf("\nPrompt used:\n%s\n", c.lastPrompt)
	attribution += fmt.Sprintf("\nGenerated at: %s\n", time.Now().Format("2006-01-02 15:04:05"))
	return attribution
}

// Name returns the name of the provider
func (c *OpenAIClient) Name() string {
	return "openai"
}

// GetLastPrompt returns the last prompt used for image generation
func (c *OpenAIClient) GetLastPrompt() string {
	return c.lastPrompt
}

// createEducationalPrompt generates a prompt optimized for language learning
func (c *OpenAIClient) createEducationalPrompt(bulgarianWord, englishTranslation string) string {
	// 25% chance to ask OpenAI for a creative style
	if rand.Float32() < 0.25 {
		if creativeStyle := c.getCreativeStyleFromOpenAI(context.Background(), englishTranslation); creativeStyle != "" {
			fmt.Printf("  Using OpenAI-suggested style: %s\n", creativeStyle)
			return fmt.Sprintf(
				"Generate a %s of: %s. "+
					"This is for the Bulgarian word '%s' which means %s. "+
					"The image should be educational and suitable for language learning flashcards. "+
					"Requirements: single main subject, plain background, clear and recognizable. "+
					"IMPORTANT: No text whatsoever. Do not include any words, letters, typography, labels, captions, or writing of any kind. Image only, without any text elements.",
				creativeStyle, englishTranslation, bulgarianWord, englishTranslation,
			)
		}
	}
	
	// Define different art styles for variety (42 styles total)
	styles := []string{
		// Original styles (1-10)
		"photorealistic, high quality photograph",
		"detailed digital illustration, clean vector art style",
		"vibrant cartoon style, animated movie quality",
		"minimalist flat design, modern graphic style",
		"watercolor painting, soft artistic style",
		"pencil sketch, detailed drawing style",
		"3D rendered, pixar-style animation",
		"oil painting, classical art style",
		"paper cut art, layered craft style",
		"isometric illustration, technical drawing style",
		
		// Requested styles (11-13)
		"superhero comic book style, dynamic action pose, bold colors, Marvel/DC aesthetic",
		"super-realistic person practicing yoga, serene wellness photography",
		"cute illustration with cats interacting with the subject, whimsical cat-themed",
		
		// Additional artistic styles (14-25)
		"impressionist painting style, Monet-inspired brushstrokes",
		"art nouveau style, decorative organic forms, Mucha-inspired",
		"pop art style, Andy Warhol inspired, bold contrasting colors",
		"Japanese ukiyo-e woodblock print style, traditional aesthetic",
		"steampunk illustration, Victorian era mechanical elements",
		"cyberpunk neon aesthetic, futuristic digital art",
		"medieval illuminated manuscript style, gold leaf details",
		"graffiti street art style, urban spray paint aesthetic",
		"stained glass window art, cathedral-inspired design",
		"mosaic tile art style, Byzantine-inspired patterns",
		"art deco style, geometric patterns, 1920s aesthetic",
		"surrealist style, Salvador Dali inspired dreamlike quality",
		
		// Photography styles (26-32)
		"macro photography style, extreme close-up detail",
		"vintage polaroid photograph, retro instant camera aesthetic",
		"film noir style, dramatic black and white photography",
		"golden hour photography, warm sunset lighting",
		"underwater photography style, ethereal aquatic atmosphere",
		"aerial drone photography, bird's eye view perspective",
		"long exposure photography, motion blur effects",
		
		// Modern digital styles (33-42)
		"vaporwave aesthetic, 80s-90s retro digital art",
		"low poly 3D art style, geometric simplified forms",
		"pixel art style, 8-bit retro video game aesthetic",
		"glitch art style, digital distortion effects",
		"double exposure photography, artistic overlay effect",
		"tilt-shift photography, miniature world effect",
		"infrared photography style, otherworldly color palette",
		"holographic iridescent style, rainbow prismatic effects",
		"origami paper folding art style, geometric paper craft",
		"chalk art style, sidewalk drawing aesthetic",
	}
	
	// Select a random style
	selectedStyle := styles[rand.Intn(len(styles))]
	fmt.Printf("  Using image style: %s\n", selectedStyle)
	
	// Create a simple, clear prompt for educational images
	return fmt.Sprintf(
		"Generate a %s of: %s. "+
			"This is for the Bulgarian word '%s' which means %s. "+
			"The image should be educational and suitable for language learning flashcards. "+
			"Requirements: single main subject, plain background, clear and recognizable. "+
			"IMPORTANT: No text whatsoever. Do not include any words, letters, typography, labels, captions, or writing of any kind. Image only, without any text elements.",
		selectedStyle, englishTranslation, bulgarianWord, englishTranslation,
	)
}

// translateBulgarianToEnglish translates a Bulgarian word to English using OpenAI
func (c *OpenAIClient) translateBulgarianToEnglish(ctx context.Context, word string) (string, error) {
	// Use OpenAI chat completion to translate
	fmt.Printf("OpenAI Translation: Using model 'gpt-4o-mini' to translate '%s'\n", word)
	
	req := openai.ChatCompletionRequest{
		Model: openai.GPT4oMini,
		Messages: []openai.ChatCompletionMessage{
			{
				Role:    openai.ChatMessageRoleUser,
				Content: fmt.Sprintf("Translate the Bulgarian word '%s' to English. Respond with only the English translation, nothing else.", word),
			},
		},
		Temperature: 0.3, // Lower temperature for more consistent translations
		MaxTokens:   50,
	}
	
	resp, err := c.client.CreateChatCompletion(ctx, req)
	if err != nil {
		return "", fmt.Errorf("translation failed: %w", err)
	}
	
	if len(resp.Choices) == 0 || resp.Choices[0].Message.Content == "" {
		return "", fmt.Errorf("no translation received")
	}
	
	translation := strings.TrimSpace(resp.Choices[0].Message.Content)
	fmt.Printf("Translated '%s' to '%s'\n", word, translation)
	
	return translation, nil
}

// getCacheFilePath generates a cache file path for the given word
func (c *OpenAIClient) getCacheFilePath(word string) string {
	// Create a hash of the word and settings
	h := md5.New()
	h.Write([]byte(word))
	h.Write([]byte(c.model))
	h.Write([]byte(c.size))
	h.Write([]byte(c.quality))
	h.Write([]byte(c.style))
	hash := hex.EncodeToString(h.Sum(nil))
	
	// Use first 2 chars as subdirectory for better file system performance
	subdir := hash[:2]
	filename := hash[2:] + ".png"
	
	return filepath.Join(c.cacheDir, subdir, filename)
}

// downloadAndCache downloads an image and saves it to the cache
func (c *OpenAIClient) downloadAndCache(ctx context.Context, url, cacheFile string) error {
	// Ensure directory exists
	dir := filepath.Dir(cacheFile)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}
	
	// Download the image
	resp, err := c.Download(ctx, url)
	if err != nil {
		return err
	}
	defer resp.Close()
	
	// Create the cache file
	out, err := os.Create(cacheFile)
	if err != nil {
		return err
	}
	defer out.Close()
	
	// Copy the data
	_, err = io.Copy(out, resp)
	return err
}

// generateImageID creates a unique ID for the image
func (c *OpenAIClient) generateImageID(word string) string {
	h := md5.New()
	h.Write([]byte(word))
	h.Write([]byte(c.model))
	return "openai_" + hex.EncodeToString(h.Sum(nil))[:8]
}

// getSizeWidth returns the width based on the size setting
func (c *OpenAIClient) getSizeWidth() int {
	switch c.size {
	case "256x256":
		return 256
	case "512x512":
		return 512
	case "1024x1024":
		return 1024
	case "1024x1792", "1792x1024": // DALL-E 3 sizes
		if strings.HasPrefix(c.size, "1024") {
			return 1024
		}
		return 1792
	default:
		return 512
	}
}

// getSizeHeight returns the height based on the size setting
func (c *OpenAIClient) getSizeHeight() int {
	switch c.size {
	case "256x256":
		return 256
	case "512x512":
		return 512
	case "1024x1024":
		return 1024
	case "1024x1792":
		return 1792
	case "1792x1024":
		return 1024
	default:
		return 512
	}
}

// getCreativeStyleFromOpenAI asks OpenAI for a creative photo style suggestion
func (c *OpenAIClient) getCreativeStyleFromOpenAI(ctx context.Context, subject string) string {
	fmt.Printf("  Asking OpenAI for creative style suggestion for '%s'...\n", subject)
	
	req := openai.ChatCompletionRequest{
		Model: openai.GPT4oMini,
		Messages: []openai.ChatCompletionMessage{
			{
				Role: openai.ChatMessageRoleSystem,
				Content: "You are a creative art director. Suggest unique, interesting photo/art styles for educational flashcard images. Be creative and varied. Respond with ONLY the style description, nothing else. Keep it concise (max 15 words).",
			},
			{
				Role: openai.ChatMessageRoleUser,
				Content: fmt.Sprintf("Suggest a creative visual style for an educational image of: %s", subject),
			},
		},
		Temperature: 0.9, // Higher temperature for more creativity
		MaxTokens:   30,
	}
	
	resp, err := c.client.CreateChatCompletion(ctx, req)
	if err != nil {
		fmt.Printf("  Failed to get creative style: %v\n", err)
		return ""
	}
	
	if len(resp.Choices) == 0 || resp.Choices[0].Message.Content == "" {
		return ""
	}
	
	style := strings.TrimSpace(resp.Choices[0].Message.Content)
	// Remove any trailing punctuation
	style = strings.TrimSuffix(style, ".")
	style = strings.TrimSuffix(style, "!")
	
	return style
}